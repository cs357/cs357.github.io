<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>LU Decomposition for Solving Linear Equations - CS 357</title>
    <link rel="icon" href="//assets/img/favicon.png">
    <link rel="shortcut icon" href="//assets/img/favicon.png" />
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="//assets/css/bootstrap.min.css">
    <!-- animate CSS -->
    <link rel="stylesheet" href="//assets/css/animate.css">
    <!-- owl carousel CSS -->
    <link rel="stylesheet" href="//assets/css/owl.carousel.min.css">
    <!-- themify CSS -->
    <link rel="stylesheet" href="//assets/css/themify-icons.css">
    <!-- flaticon CSS -->
    <link rel="stylesheet" href="//assets/css/flaticon.css">
    <!-- font awesome CSS -->
    <link rel="stylesheet" href="//assets/css/magnific-popup.css">
    <!-- swiper CSS -->
    <link rel="stylesheet" href="//assets/css/slick.css">
    <!-- style CSS -->
    <link rel="stylesheet" href="//assets/css/style.css">
    <!-- opengraph -->
    <meta property="og:site_name" content="CS 357 Fall 2024" />
    <meta property="og:title" content="LU Decomposition for Solving Linear Equations - CS 357" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="//assets/img/photos/group-CIF.png" />
    <!-- Mathjax Support -->
    <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.0/es5/latest?tex-mml-chtml.js">
    </script>

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-157880752-1', 'auto');
        ga('send', 'pageview');
    </script>
    
</head>

<nav class="main_menu home_menu">
    <div class="container">
        <div class="row align-items-center">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light">
                    <a class="navbar-brand" href="/">
                        
                            <img class="mr-2" style="max-height:25pt" src="//assets/img/logo.png" alt="logo"> CS 357 <span class="badge badge-success">Fall 2024</span>
                        
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse"
                            data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                            aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse main-menu-item justify-content-end"
                         id="navbarSupportedContent">
                        <ul class="navbar-nav align-items-center">
                            <li class="nav-item ignore-md-custom-style">
                                <a class="nav-link" href="/pages/syllabus.html">Syllabus</a>
                            </li>
                            <li class="nav-item ignore-md-custom-style">
                                <a class="nav-link" href="/pages/schedule.html">Schedule</a>
                            </li>
                            <li class="nav-item ignore-md-custom-style">
                                <a class="nav-link" href="/pages/contact.html">Support</a>
                            </li>
                            <li class="nav-item ignore-md-custom-style">
                                <a class="nav-link" href="/pages/lectures.html">Group Activities</a>
                            </li>
                            <li class="nav-item ignore-md-custom-style">
                                <a class="nav-link" href="/pages/quizzes.html">Quizzes</a>
                            </li>
                             <!--Mobile view has different textbook button. -->
                            <li class="d-lg-none nav-item ignore-md-custom-style">
                                <a class="nav-link" href="https://cs357.github.io/textbook/">Online Textbook</a>
                            </li>
                            <li class="d-none d-lg-block ignore-md-custom-style">
                                <a class="btn_1" href="https://cs357.github.io/textbook/">Online Textbook</a>
                            </li>
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
        
    </div>
</nav>

<body>
<style>
    p:not(.ignore-md-custom-style) {
        line-height: unset;
        margin-bottom: 1em;
        color: black;
    }

    ul {
        all: unset;
    }

    li:not(.ignore-md-custom-style) {
        margin-left: 20pt;
    }

    h2:not(.ignore-md-custom-style) {
        margin-top: 2em;
        font-weight: 500;
    }

    h3:not(.ignore-md-custom-style) {
        margin-top: 1em;
    }
</style>
<section class="section_padding">
    <div class="container text-dark">
        <h1 id="lu-decomposition-for-solving-linear-equations">LU Decomposition for Solving Linear Equations</h1>

<hr />

<h2 id="learning-objectives">Learning objectives</h2>

<ul>
  <li>Describe the factorization \({\bf A} = {\bf LU}\).</li>
  <li>Compare the cost of LU with other operations such as matrix-matrix multiplication.</li>
  <li>Identify the problems with using LU factorization.</li>
  <li>Implement an LU decomposition algorithm.</li>
  <li>Given an LU decomposition for \({\bf A}\), solve the system \({\bf Ax} = {\bf b}\).</li>
  <li>Give examples of matrices for which pivoting is needed.</li>
  <li>Implement an LUP decomposition algorithm.</li>
  <li>Manually compute LU and LUP decompositions.</li>
  <li>Compute and use LU decompositions using library functions.</li>
</ul>

<h2 id="forward-substitution-algorithm">Forward substitution algorithm</h2>

<p>The <strong><em>forward substitution algorithm</em></strong> solves the linear system \({\bf Lx} = {\bf b}\) where \({\bf L}\) is a lower triangular matrix.</p>

<p>A lower-triangular linear system \({\bf L}{\bf x} = {\bf b}\) can be written in matrix form:</p>

\[\begin{bmatrix}
\ell_{11} &amp; 0         &amp; \ldots &amp; 0 \\
\ell_{21} &amp; \ell_{22} &amp; \ldots &amp; 0 \\
\vdots    &amp; \vdots    &amp; \ddots &amp; 0 \\
\ell_{n1} &amp; \ell_{n2} &amp; \ldots &amp; \ell_{nn} \\
\end{bmatrix}
\begin{bmatrix}
x_1 \\ x_2 \\ \vdots \\ x_n
\end{bmatrix}
=
\begin{bmatrix}
b_1 \\ b_2 \\ \vdots \\ b_n
\end{bmatrix}.\]

<p>This can also be written as the set of linear equations:</p>

\[\begin{matrix}
\ell_{11} x_1 &amp;   &amp;               &amp;   &amp;        &amp;   &amp;               &amp; = &amp; b_1 \\
\ell_{21} x_1 &amp; + &amp; \ell_{22} x_2 &amp;   &amp;        &amp;   &amp;               &amp; = &amp; b_2 \\
\vdots        &amp; + &amp; \vdots        &amp; + &amp; \ddots &amp;   &amp;               &amp; = &amp; \vdots \\
\ell_{n1} x_1 &amp; + &amp; \ell_{n2} x_2 &amp; + &amp; \ldots &amp; + &amp; \ell_{nn} x_n &amp; = &amp; b_n.
\end{matrix}\]

<p>The forward substitution algorithm solves a lower-triangular linear system by working from the top down and solving each variable in turn. In math this is:</p>

\[\begin{aligned}
x_1 &amp;= \frac{b_1}{\ell_{11}} \\
x_2 &amp;= \frac{b_2 - \ell_{21} x_1}{\ell_{22}} \\
&amp;\vdots \\
x_n &amp;= \frac{b_n - \sum_{j=1}^{n-1} \ell_{nj} x_j}{\ell_{nn}}.
\end{aligned}\]

<p>The properties of the forward substitution algorithm are:</p>

<ol>
  <li>If any of the diagonal elements \(L_{ii}\) are zero then the system is singular and cannot be solved.</li>
  <li>If all diagonal elements of \({\bf L}\) are non-zero then the system has a unique solution.</li>
  <li>The number of operations for the forward substitution algorithm is \(O(n^2)\) as \(n \to \infty\).</li>
</ol>

<p>The code for the forward substitution algorithm to solve \({\bf L x} = {\bf b}\) is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">forward_sub</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s">"""x = forward_sub(L, b) is the solution to L x = b
       L must be a lower-triangular matrix
       b must be a vector of the same leading dimension as L
    """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">L</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">-=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<h2 id="back-substitution-algorithm">Back substitution algorithm</h2>

<p>The <strong><em>back substitution algorithm</em></strong> solves the linear system \({\bf U x} = {\bf b}\) where \({\bf U}\) is an upper-triangular matrix. It is the backwards version of forward substitution.</p>

<p>The upper-triangular system \({\bf U}x = b\) can be written as the set of linear equations:</p>

\[\begin{matrix}
u_{11} x_1 &amp; + &amp; u_{12} x_2 &amp; + &amp; \ldots &amp; + &amp; u_{1n} x_n &amp; = &amp; b_1 \\
           &amp;   &amp; u_{22} x_2 &amp; + &amp; \ldots &amp; + &amp; u_{2n} x_n &amp; = &amp; b_2 \\
           &amp;   &amp;            &amp;   &amp; \ddots &amp;   &amp; \vdots     &amp; = &amp; \vdots \\
           &amp;   &amp;            &amp;   &amp;        &amp;   &amp; u_{nn} x_n &amp; = &amp; b_n.
\end{matrix}\]

<p>The back substitution solution works from the bottom up to give:</p>

\[\begin{aligned}
x_n &amp;= \frac{b_n}{u_{nn}} \\
x_{n-1} &amp;= \frac{b_{n-1} - u_{n-1n} x_n}{u_{n-1n-1}} \\
&amp;\vdots \\
x_1 &amp;= \frac{b_1 - \sum_{j=2}^n u_{1j} x_j}{u_{11}}.
\end{aligned}\]

<p>The properties of the back substitution algorithm are:</p>

<ol>
  <li>If any of the diagonal elements \(U_{ii}\) are zero then the system is singular and cannot be solved.</li>
  <li>If all diagonal elements of \({\bf U}\) are non-zero then the system has a unique solution.</li>
  <li>The number of operations for the back substitution algorithm is \(O(n^2)\) as \(n \to \infty\).</li>
</ol>

<p>The code for the back substitution algorithm to solve \({\bf U x} = {\bf b}\) is:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">back_sub</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s">"""x = back_sub(U, b) is the solution to U x = b
       U must be an upper-triangular matrix
       b must be a vector of the same leading dimension as U
    """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">U</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">-=</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<h2 id="lu-decomposition">LU decomposition</h2>

<p>The <strong><em>LU decomposition</em></strong> of a matrix \({\bf A}\) is the pair of matrices \({\bf L}\) and \({\bf U}\) such that:</p>

<ol>
  <li>\({\bf A} = {\bf LU}\)</li>
  <li>\({\bf L}\) is a lower-triangular matrix with all diagonal entries equal to 1</li>
  <li>\({\bf U}\) is an upper-triangular matrix.</li>
</ol>

<p>The properties of the LU decomposition are:</p>

<ol>
  <li>The LU decomposition may not exist for a matrix \({\bf A}\).</li>
  <li>If the LU decomposition exists then it is unique.</li>
  <li>The LU decomposition provides an efficient means of solving linear equations.</li>
  <li>The reason that \({\bf L}\) has all diagonal entries set to 1 is that this means the LU decomposition is unique. This choice is somewhat arbitrary (we could have decided that \({\bf U}\) must have 1 on the diagonal) but it is the standard choice.</li>
  <li>We use the terms <strong><em>decomposition</em></strong> and <strong><em>factorization</em></strong> interchangeably to mean writing a matrix as a product of two or more other matrices, generally with some defined properties (such as lower/upper triangular).</li>
</ol>

<h4 id="example-lu-decomposition">Example: LU decomposition</h4>

<p>Consider the matrix
\(A =
\begin{bmatrix}
1 &amp; 2 &amp; 2 \\
4 &amp; 4 &amp; 2 \\
4 &amp; 6 &amp; 4
\end{bmatrix}
.\)</p>

<p>The LU factorization is
\({\bf A} = {\bf LU} =
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
4 &amp; 1 &amp; 0 \\
4 &amp; 0.5 &amp; 1
\end{bmatrix}
\begin{bmatrix}
1 &amp; 2 &amp; 2 \\
0 &amp; -4 &amp; -6 \\
0 &amp; 0 &amp; -1
\end{bmatrix}.\)</p>

<h4 id="example-matrix-for-which-lu-decomposition-fails">Example: matrix for which LU decomposition fails</h4>

<p>An example of a matrix which has no LU decomposition is</p>

\[{\bf A} = \begin{bmatrix}
0 &amp; 1 \\
2 &amp; 1
\end{bmatrix}.\]

<p>If we try and find the LU decomposition of this matrix then we get</p>

\[\overbrace{\begin{bmatrix}
0 &amp; 1 \\
2 &amp; 1
\end{bmatrix}}^{A}
=
\overbrace{\begin{bmatrix}
1 &amp; 0 \\
\ell_{21} &amp; 1
\end{bmatrix}}^{L}
\overbrace{\begin{bmatrix}
u_{11} &amp; u_{12} \\
0 &amp; u_{22}
\end{bmatrix}}^{U}
=
\begin{bmatrix}
u_{11} &amp; u_{12} \\
\ell_{21} u_{11} &amp; \ell_{21} u_{12} + u_{22}
\end{bmatrix}.\]

<p>Equating the individual entries gives us four equations to solve. The top-left and bottom-left entries give the two equations:</p>

\[\begin{aligned}
u_{11} &amp;= 0 \\
\ell_{21} u_{11} &amp;= 2.
\end{aligned}\]

<p>These equations have no solution, so \({\bf A}\) does not have an LU decomposition.</p>

<h2 id="solving-lu-decomposition-linear-systems">Solving LU decomposition linear systems</h2>

<p>Knowing the LU decomposition for a matrix \({\bf A}\) allows us to solve the linear system \({\bf A x} = {\bf b}\) using a combination of forward and back substitution. In equations this is:</p>

\[\begin{aligned}
{\bf A x} &amp;= {\bf b} \\
{\bf L U x} &amp;= {\bf b} \\
{\bf U x} &amp;= {\bf L}^{-1} {\bf b} \\
{\bf x} &amp;= {\bf U}^{-1} ({\bf L}^{-1} {\bf b}),
\end{aligned}\]

<p>where we first evaluate \({\bf L}^{-1} {\bf b}\) using forward substitution and then evaluate \({\bf x} = {\bf U}^{-1} ({\bf L}^{-1} {\bf b})\) using back substitution.</p>

<p>An equivalent way to write this is to introduce a new vector \({\bf y}\) defined by \(y = {\bf U x}\). This means we can rewrite \({\bf A x} = {\bf b}\) as:</p>

\[\begin{aligned}
{\bf A x} &amp;= {\bf b} \\
{\bf L U x} &amp;= {\bf b} \\
{\bf L y} &amp;= {\bf b} \qquad  \text{use forward substitution to obtain } {\bf y} \\
{\bf U x} &amp;= {\bf y} \qquad  \text{use backward substitution to obtain } {\bf x}
\end{aligned}\]

<p>We have thus replaced \({\bf A x} = {\bf b}\) with <em>two</em> linear systems: \({\bf L y} = {\bf b}\) and \({\bf U x} = {\bf y}\). These two linear systems can then be solved one after the other using forward and back substitution.</p>

<p>The <strong><em>LU solve algorithm</em></strong> for solving the linear system \({\bf L U x} = {\bf b}\) written as code is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">lu_solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s">"""x = lu_solve(L, U, b) is the solution to L U x = b
       L must be a lower-triangular matrix
       U must be an upper-triangular matrix of the same size as L
       b must be a vector of the same leading dimension as L
    """</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">forward_sub</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">back_sub</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<p>The number of operations for the LU solve algorithm is \(O(n^2)\) as \(n \to \infty\).</p>

<h2 id="the-lu-decomposition-algorithm">The LU decomposition algorithm</h2>

<p>Given a matrix \({\bf A}\) there are many different algorithms to find the matrices \({\bf L}\) and \({\bf U}\) for the LU decomposition. Here we will use the <strong><em>recursive leading-row-column LU algorithm</em></strong>. This algorithm is based on writing \({\bf A} = {\bf LU}\) in block form as:</p>

\[\begin{aligned}
\begin{bmatrix}
a_{11} &amp; \boldsymbol{a}_{12} \\
\boldsymbol{a}_{21} &amp; {\bf A}_{22}
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 &amp; \boldsymbol{0} \\
\boldsymbol{\ell}_{21} &amp; {\bf L}_{22}
\end{bmatrix}
\begin{bmatrix}
u_{11} &amp; \boldsymbol{u}_{12} \\
\boldsymbol{0} &amp; {\bf U}_{22}
\end{bmatrix}
\\
&amp;=
\begin{bmatrix}
u_{11} &amp; \boldsymbol{u}_{12} \\
u_{11} \boldsymbol{\ell}_{21} &amp; (\boldsymbol{\ell}_{21} \boldsymbol{u}_{12} + {\bf L}_{22} {\bf U}_{22})
\end{bmatrix}.
\end{aligned}\]

<p>In the above block form of the \(n \times n\) matrix \({\bf A}\), the entry \(a_{11}\) is a scalar, \(\boldsymbol{a}_{12}\) is a \(1 \times (n-1)\) row vector, \(\boldsymbol{a}_{12}\) is an \((n-1) \times 1\) column vector, and \({\bf A}_{22}\) is an \((n-1) \times (n-1)\) matrix.</p>

<p>Comparing the left- and right-hand side entries of the above block matrix equation we see that:</p>

\[\begin{aligned}
a_{11} &amp;= u_{11} \\
\boldsymbol{a}_{12} &amp;= \boldsymbol{u}_{12} \\
\boldsymbol{a}_{21} &amp;= u_{11} \boldsymbol{\ell}_{21} \\
A_{22} &amp;= \boldsymbol{\ell}_{21} \boldsymbol{u}_{12} + {\bf L}_{22} {\bf U}_{22}.
\end{aligned}\]

<p>These four equations can be rearranged to solve for the components of the \({\bf L}\) and \({\bf U}\) matrices as:</p>

\[\begin{aligned}
u_{11} &amp;= a_{11}\\
\boldsymbol{u}_{12} &amp;= \boldsymbol{a}_{12} \\
\boldsymbol{\ell}_{21} &amp;= \frac{1}{u_{11}} \boldsymbol{a}_{21} \\
{\bf L}_{22} {\bf U}_{22} &amp;= \underbrace{ {\bf A}_{22} - \boldsymbol{a}_{21} (a_{11})^{-1} \boldsymbol{a}_{12}}_{\text{Schur complement } S_{22}}.
\end{aligned}\]

<p>The first three equations above can be immediately evaluated to give the first row and column of \({\bf L}\) and \({\bf U}\). The last equation can then have its right-hand-side evaluated, which gives the <strong><em>Schur complement</em></strong> \(S_{22}\) of \({\bf A}\). We thus have the equation \({\bf L}_{22} {\bf U}_{22} = {\bf S}_{22}\), which is an \((n-1) \times (n-1)\) LU decomposition problem which we can recursively solve.</p>

<p>The code for the <strong><em>recursive leading-row-column LU algorithm</em></strong> to find \({\bf L}\) and \({\bf U}\) for \({\bf A} = {\bf LU}\) is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">lu_decomp</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="s">"""(L, U) = lu_decomp(A) is the LU decomposition A = L U
       A is any matrix
       L will be a lower-triangular matrix with 1 on the diagonal, the same shape as A
       U will be an upper-triangular matrix, the same shape as A
    """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>

    <span class="n">A11</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A12</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">A21</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A22</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A11</span>

    <span class="c1"># L[0,1:] = np.zeros(n-1)
</span>    <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A12</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A21</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">/</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># U[1:,0] = np.zeros(n-1)
</span>
    <span class="n">S22</span> <span class="o">=</span> <span class="n">A22</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">outer</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:])</span>
    <span class="p">(</span><span class="n">L22</span><span class="p">,</span> <span class="n">U22</span><span class="p">)</span> <span class="o">=</span> <span class="n">lu_decomp</span><span class="p">(</span><span class="n">S22</span><span class="p">)</span>

    <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">L22</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">U22</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span>
</code></pre></div></div>

<p>The number of operations for the recursive leading-row-column LU decomposition algorithm is \(O(n^3)\) as \(n \to \infty\).</p>

<h2 id="solving-linear-systems-using-lu-decomposition">Solving linear systems using LU decomposition</h2>

<p>We can put the above sections together to produce an algorithm for solving the system \({\bf A x} = {\bf b}\), where we first compute the LU decomposition of \({\bf A}\) and then use forward and backward substitution to solve for \({\bf x}\).</p>

<p>The properties of this algorithm are:</p>

<ol>
  <li>The algorithm may fail, even if \({\bf A}\) is invertible.</li>
  <li>The number of operations in the algorithm is \(\mathcal{O}(n^3)\) as \(n \to \infty\).</li>
</ol>

<p>The code for the <strong><em>linear solver using LU decomposition</em></strong> is:
import numpy as np</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">linear_solve_without_pivoting</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s">"""x = linear_solve_without_pivoting(A, b) is the solution to A x = b (computed without pivoting)
       A is any matrix
       b is a vector of the same leading dimension as A
       x will be a vector of the same leading dimension as A
    """</span>
    <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">=</span> <span class="n">lu_decomp</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lu_solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<h2 id="pivoting">Pivoting</h2>

<p>The LU decomposition can fail when the top-left entry in the matrix \({\bf A}\) is zero or very small compared to other entries. <strong><em>Pivoting</em></strong> is a strategy to mitigate this problem by rearranging the rows and/or columns of \({\bf A}\) to put a larger element in the top-left position.</p>

<p>There are many different pivoting algorithms. The most common of these are <strong><em>full pivoting</em></strong>, <strong><em>partial pivoting</em></strong>, and <strong><em>scaled partial pivoting</em></strong>. We will only discuss <strong><em>partial pivoting</em></strong> in detail.</p>

<p>1) <strong><em>Partial pivoting</em></strong> only rearranges the rows of \({\bf A}\) and leaves the columns fixed.</p>

<div class="figure"> <img src="//assets/img/figs/partialPivoting.png" width="500" /> </div>

<p><br />
2) <strong><em>Full pivoting</em></strong> rearranges both rows and columns.</p>

<div class="figure"> <img src="//assets/img/figs/fullPivoting.png" width="500" /> </div>

<p><br />
3) <strong><em>Scaled partial pivoting</em></strong> approximates full pivoting without actually rearranging columns.</p>

<h2 id="lu-decomposition-with-partial-pivoting">LU decomposition with partial pivoting</h2>

<p>The <strong><em>LU decomposition with partial pivoting (LUP)</em></strong> of an \(n \times n\) matrix \({\bf A}\) is
the triple of matrices \({\bf L}\), \({\bf U}\), and \({\bf P}\) such that:</p>

<ol>
  <li>\({\bf P A} = {\bf LU} \)</li>
  <li>\({\bf L}\) is an \(n \times n\) lower-triangular matrix with all diagonal entries equal to 1.</li>
  <li>\({\bf U}\) is an \(n \times n\) upper-triangular matrix.</li>
  <li>\({\bf P}\) is an \(n \times n\) permutation matrix.</li>
</ol>

<p>The properties of the LUP decomposition are:</p>

<ol>
  <li>The permutation matrix \({\bf P}\) acts to permute the rows of \({\bf A}\). This attempts to put large entries in the top-left position of \({\bf A}\) and each sub-matrix in the recursion, to avoid needing to divide by a small or zero element.</li>
  <li>The LUP decomposition always exists for a matrix \({\bf A}\).</li>
  <li>The LUP decomposition of a matrix \({\bf A}\) is not unique.</li>
  <li>The LUP decomposition provides a more robust method of solving linear systems than LU decomposition without pivoting, and it is approximately the same cost.</li>
</ol>

<h2 id="solving-lup-decomposition-linear-systems">Solving LUP decomposition linear systems</h2>

<p>Knowing the LUP decomposition for a matrix \({\bf A}\) allows us to solve the linear system \({\bf A x} = {\bf b}\)
by first applying \({\bf P}\) and then using the LU solver.
In equations we start by taking \({\bf A x} = {\bf b}\) and multiplying both sides by \({\bf P}\), giving</p>

\[\begin{aligned}
{\bf Ax} &amp;= {\bf b} \\
{\bf PAx} &amp;= {\bf Pb} \\
{\bf LUx} &amp;= {\bf Pb}.
\end{aligned}\]

<p>The code for the <strong><em>LUP solve algorithm</em></strong> to solve the linear system ${\bf L U x} = {\bf P b}$ is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">lup_solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s">"""x = lup_solve(L, U, P, b) is the solution to L U x = P b
       L must be a lower-triangular matrix
       U must be an upper-triangular matrix of the same shape as L
       P must be a permutation matrix of the same shape as L
       b must be a vector of the same leading dimension as L
    """</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lu_solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<p>The number of operations for the LUP solve algorithm is \(\mathcal{O}(n^2)\) as \(n \to \infty\).</p>

<h2 id="the-lup-decomposition-algorithm">The LUP decomposition algorithm</h2>

<p>Just as there are different LU decomposition algorithms, there are also different algorithms to find a LUP decomposition. Here we use the <strong><em>recursive leading-row-column LUP algorithm</em></strong>.</p>

<p>This algorithm is a recursive method for finding \({\bf L}\), \({\bf U}\), and \({\bf P}\) so that \({\bf P A} = {\bf L U}\). It consists of the following steps.</p>

<p>1) First choose \(i\) so that row \(i\) in \({\bf A}\) has the largest absolute first entry. That is, \(\vert A_{i1}\vert \ge \vert A_{j1}\vert\) for all \(j\). Let \({\bf P}_1\) be the permutation matrix that pivots (shifts) row \(i\) to the first row, and leaves all other rows in order. We can explicitly write \({\bf P}_1\) as</p>

\[{\bf P}_1 =
\begin{bmatrix}
0_{1(i-1)}     &amp; 1 &amp; 0_{1(n-i)} \\
I_{(i-1)(i-1)} &amp; 0 &amp; 0_{(i-1)(n-i)} \\
0_{(n-i)(i-1)} &amp; 0 &amp; I_{(n-i)(n-i)}
\end{bmatrix}
=
\begin{bmatrix}
0      &amp; \ldots &amp; 0      &amp; 1      &amp; 0      &amp; \ldots &amp; 0 \\
1      &amp; \ldots &amp; 0      &amp; 0      &amp; 0      &amp; \ldots &amp; 0 \\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ldots &amp; 0 \\
0      &amp; \ldots &amp; 1      &amp; 0      &amp; 0      &amp; \ldots &amp; 0 \\
0      &amp; \ldots &amp; 0      &amp; 0      &amp; 1      &amp; \ldots &amp; 0 \\
\vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ldots &amp; 0 \\
0      &amp; \ldots &amp; 0      &amp; 0      &amp; 0      &amp; \ldots &amp; 1
\end{bmatrix}.\]

<p>2) Write \(\bar{ {\bf A} }\) to denote the pivoted \({\bf A}\) matrix, so \(\bar{ {\bf A} } = {\bf P}_1 {\bf A}\).</p>

<p>3) Let \({\bf P}_2\) be a permutation matrix that leaves the first row where it is, but permutes all other rows. We can write \({\bf P}_2\) as
\({\bf P}_2 =
\begin{bmatrix}
1              &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; P_{22}
\end{bmatrix},\)
where \({\bf P}_{22}\) is an \((n-1) \times (n-1)\) permutation matrix.</p>

<p>4) Factorize the (unknown) full permutation matrix \({\bf P}\) as the product of \({\bf P}_2\) and \({\bf P}_1\), so \({\bf P} = {\bf P}_2 {\bf P}_1\). This means that \({\bf P} A = {\bf P}_2 {\bf P}_1 A = {\bf P}_2 \bar{ {\bf A} }\), which first shifts row \(i\) of \({\bf A}\) to the top, and then permutes the remaining rows. This is a completely general permutation matrix \({\bf P}\), but this factorization is key to enabling a recursive algorithm.</p>

<p>5) Using the factorization \({\bf P} = {\bf P}_2 {\bf P}_1\), now write the LUP factorization in block form as</p>

\[\begin{aligned}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\bf P A} &amp;= {\bf L U} \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\bf P_2} \bar{ {\bf A} } &amp;= {\bf L U} \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{bmatrix}
1              &amp; \boldsymbol{0} \\
\boldsymbol{0} &amp; {\bf P}_{22}
\end{bmatrix}
\begin{bmatrix}
\bar{a}_{11} &amp; \bar{\boldsymbol{a}}_{12} \\
\bar{\boldsymbol{a}}_{21} &amp; \bar{ {\bf A} }_{22}
\end{bmatrix}
&amp;=
\begin{bmatrix}
1 &amp; \boldsymbol{0} \\
\boldsymbol{\ell}_{21} &amp; {\bf L}_{22}
\end{bmatrix}
\begin{bmatrix}
u_{11} &amp; \boldsymbol{u}_{12} \\
\boldsymbol{0} &amp; {\bf U}_{22}
\end{bmatrix}
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{bmatrix}
\bar{a}_{11} &amp; \bar{\boldsymbol{a}}_{12} \\
{\bf P}_{22} \bar{\boldsymbol{a}}_{21} &amp; {\bf P}_{22} \bar{ {\bf A} }_{22}
\end{bmatrix}
&amp;=
\begin{bmatrix}
u_{11} &amp; \boldsymbol{u}_{12} \\
u_{11} \boldsymbol{\ell}_{21} &amp; (\boldsymbol{\ell}_{21} \boldsymbol{u}_{12} + {\bf L}_{22} {\bf U}_{22})
\end{bmatrix}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{aligned}\]

<p>6) Equating the entries in the above matrices gives the equations</p>

\[\begin{aligned}
\bar{a}_{11} &amp;= u_{11} \\
\bar{\boldsymbol{a}}_{12} &amp;= \boldsymbol{u}_{12} \\
{\bf P}_{22} \bar{\boldsymbol{a}}_{21} &amp;= u_{11} \boldsymbol{\ell}_{21} \\
{\bf P}_{22} \bar{A}_{22} &amp;= \boldsymbol{\ell}_{21} \boldsymbol{u}_{12} + {\bf L}_{22} {\bf U}_{22}.
\end{aligned}\]

<p>7) Substituting the first three equations above into the last one and rearranging gives</p>

\[{\bf P}_{22} \underbrace{\Bigl(\bar{A}_{22} - \bar{\boldsymbol{a}}_{21} (\bar{a}_{11})^{-1} \bar{\boldsymbol{a}}_{12}\Bigr)}_{\text{Schur complement } {\bf S}_{22}} = {\bf L}_{22} {\bf U}_{22}.\]

<p>8) Recurse to find the LUP decomposition of \(S_{22}\), resulting in \({\bf L}_{22}\), \({\bf U}_{22}\), and \({\bf P}_{22}\) that satisfy the above equation.</p>

<p>9) Solve for the first rows and columns of \({\bf L}\) and \({\bf U}\) with the above equations to give</p>

\[\begin{aligned}
u_{11} &amp;= \bar{a}_{11} \\
\boldsymbol{u}_{12} &amp;= \bar{\boldsymbol{a}}_{12} \\
\boldsymbol{\ell}_{21} &amp;= \frac{1}{\bar{a}_{11}} {\bf P}_{22} \bar{\boldsymbol{a}}_{21}.
\end{aligned}\]

<p>10) Finally, reconstruct the full matrices \({\bf L}\), \({\bf U}\), and \({\bf P}\) from the component parts.</p>

<p>In code the <strong><em>recursive leading-row-column LUP algorithm</em></strong> for finding the LU decomposition of \({\bf A}\) with partial pivoting is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">lup_decomp</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="s">"""(L, U, P) = lup_decomp(A) is the LUP decomposition P A = L U
       A is any matrix
       L will be a lower-triangular matrix with 1 on the diagonal, the same shape as A
       U will be an upper-triangular matrix, the same shape as A
       P will be a permutation matrix, the same shape as A
    """</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">A_bar</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="p">,:],</span> <span class="n">A</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):,:]])</span>

    <span class="n">A_bar11</span> <span class="o">=</span> <span class="n">A_bar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A_bar12</span> <span class="o">=</span> <span class="n">A_bar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">A_bar21</span> <span class="o">=</span> <span class="n">A_bar</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A_bar22</span> <span class="o">=</span> <span class="n">A_bar</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">S22</span> <span class="o">=</span> <span class="n">A_bar22</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A_bar21</span><span class="p">,</span> <span class="n">A_bar12</span><span class="p">)</span> <span class="o">/</span> <span class="n">A_bar11</span>

    <span class="p">(</span><span class="n">L22</span><span class="p">,</span> <span class="n">U22</span><span class="p">,</span> <span class="n">P22</span><span class="p">)</span> <span class="o">=</span> <span class="n">lup_decomp</span><span class="p">(</span><span class="n">S22</span><span class="p">)</span>

    <span class="n">L11</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">U11</span> <span class="o">=</span> <span class="n">A_bar11</span>

    <span class="n">L12</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">U12</span> <span class="o">=</span> <span class="n">A_bar12</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">L21</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P22</span><span class="p">,</span> <span class="n">A_bar21</span><span class="p">)</span> <span class="o">/</span> <span class="n">A_bar11</span>
    <span class="n">U21</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">block</span><span class="p">([[</span><span class="n">L11</span><span class="p">,</span> <span class="n">L12</span><span class="p">],</span> <span class="p">[</span><span class="n">L21</span><span class="p">,</span> <span class="n">L22</span><span class="p">]])</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">block</span><span class="p">([[</span><span class="n">U11</span><span class="p">,</span> <span class="n">U12</span><span class="p">],</span> <span class="p">[</span><span class="n">U21</span><span class="p">,</span> <span class="n">U22</span><span class="p">]])</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">block</span><span class="p">([</span>
        <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span>                  <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">))],</span>
        <span class="p">[</span><span class="n">P22</span><span class="p">[:,:(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span>      <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">P22</span><span class="p">[:,</span><span class="n">i</span><span class="p">:]]</span>
    <span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
</code></pre></div></div>

<p>The properties of the recursive leading-row-column LUP decomposition algorithm are:</p>

<ol>
  <li>
    <p>The computational complexity (number of operations) of the algorithm is \(\mathcal{O}(n^3)\) as \(n \to \infty\).</p>
  </li>
  <li>
    <p>The last step in the code that computes \({\bf P}\) does not do so by constructing and multiplying \({\bf P}_2\) and \({\bf P}_1\). This is because this would be an \(\mathcal{O}(n^3)\) step, making the whole algorithm \(\mathcal{O}(n^4)\). Instead we take advantage of the special structure of \({\bf P}_2\) and \({\bf P}_1\) to compute \({\bf P}\) with \(\mathcal{O}(n^2)\) work.</p>
  </li>
</ol>

<h2 id="solving-linear-systems-using-lup-decomposition">Solving linear systems using LUP decomposition</h2>

<p>Just as with the plain LU decomposition, we can use LUP decomposition to solve the linear system \({\bf A x }= {\bf b}\). This is the <strong><em>linear solver using LUP decomposition</em></strong> algorithm.</p>

<p>The properties of this algorithm are:</p>

<ol>
  <li>The algorithm may fail.  In particular if \({\bf A}\) is singular (or singular
in finite precision), U will have a zero on it’s diagonal.</li>
  <li>The number of operations in the algorithm is \(\mathcal{O}(n^3)\) as \(n \to \infty\).</li>
</ol>

<p>The code for the <strong><em>linear solver using LUP decomposition</em></strong> is:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">def</span> <span class="nf">linear_solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s">"""x = linear_solve(A, b) is the solution to A x = b (computed with partial pivoting)
       A is any matrix
       b is a vector of the same leading dimension as A
       x will be a vector of the same leading dimension as A
    """</span>
    <span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span> <span class="o">=</span> <span class="n">lup_decomp</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lup_solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<h4 id="example-matrix-for-which-lup-decomposition-succeeds-but-lu-decomposition-fails">Example: matrix for which LUP decomposition succeeds but LU decomposition fails</h4>

<p>Recall our example of a matrix which has no LU decomposition:</p>

\[{\bf A} = \begin{bmatrix}
0 &amp; 1 \\
2 &amp; 1
\end{bmatrix}.\]

<p>To find the LUP decomposition of \({\bf A}\), we first write the permutation matrix \({\bf P}\) that shifts the second row to the top, so that the top-left entry has the largest possible magnitude. This gives</p>

\[\overbrace{\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{bmatrix}}^{P}
\overbrace{\begin{bmatrix}
0 &amp; 1 \\
2 &amp; 1
\end{bmatrix}}^{A}
=
\overbrace{\begin{bmatrix}
2 &amp; 1 \\
0 &amp; 1
\end{bmatrix}}^{\bar{A}}
=
\overbrace{\begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}}^{L}
\overbrace{\begin{bmatrix}
2 &amp; 1 \\
0 &amp; 1
\end{bmatrix}}^{U}.\]

<h2 id="review-questions">Review Questions</h2>

<ul>
  <li>See this <a href="/cs357/fa2020/reviews/rev-9-linsys.html">review link</a></li>
</ul>

<h2 id="changelog">ChangeLog</h2>

<ul>
  <li>2023-10-20 Yuxuan Chen <a href="mailto:yuxuan19@illinois.edu">yuxuan19@illinois.edu</a>: update lu_decomp() code</li>
  <li>2018-02-28 Erin Carrier <a href="mailto:ecarrie2@illinois.edu">ecarrie2@illinois.edu</a>: fix error in ludecomp() code</li>
  <li>2018-02-22 Erin Carrier <a href="mailto:ecarrie2@illinois.edu">ecarrie2@illinois.edu</a>: update properties for solving using LUP</li>
  <li>2018-01-14 Erin Carrier <a href="mailto:ecarrie2@illinois.edu">ecarrie2@illinois.edu</a>: removes demo links</li>
  <li>2017-11-02 John Doherty <a href="mailto:jjdoher2@illinois.edu">jjdoher2@illinois.edu</a>: fixed typo in back substitution</li>
  <li>2017-11-02 Arun Lakshmanan <a href="mailto:lakshma2@illinois.edu">lakshma2@illinois.edu</a>: minor fix in lup_solve(), add changelog</li>
  <li>2017-10-25 Nathan Bowman <a href="mailto:nlbowma2@illinois.edu">nlbowma2@illinois.edu</a>: added review questions</li>
  <li>2017-10-23 Erin Carrier <a href="mailto:ecarrie2@illinois.edu">ecarrie2@illinois.edu</a>: fix links</li>
  <li>2017-10-20 Matthew West <a href="mailto:mwest@illinois.edu">mwest@illinois.edu</a>: minor fix in back_sub()</li>
  <li>2017-10-19 Nathan Bowman <a href="mailto:nlbowma2@illinois.edu">nlbowma2@illinois.edu</a>: minor existence of LUP</li>
  <li>2017-10-17 Luke Olson <a href="mailto:lukeo@illinois.edu">lukeo@illinois.edu</a>: update links</li>
  <li>2017-10-17 Erin Carrier <a href="mailto:ecarrie2@illinois.edu">ecarrie2@illinois.edu</a>: fixes</li>
  <li>2017-10-16 Matthew West <a href="mailto:mwest@illinois.edu">mwest@illinois.edu</a>: first complete draft</li>
</ul>

    </div>
</section>

</body>
<script src="//assets/js/jquery-1.12.1.min.js"></script>
<!-- popper js -->
<script src="//assets/js/popper.min.js"></script>
<!-- bootstrap js -->
<script src="//assets/js/bootstrap.min.js"></script>
<!-- easing js -->
<script src="//assets/js/jquery.magnific-popup.js"></script>
<!-- swiper js -->
<script src="//assets/js/swiper.min.js"></script>
<!-- swiper js -->
<script src="//assets/js/masonry.pkgd.js"></script>
<!-- particles js -->
<script src="//assets/js/owl.carousel.min.js"></script>
<script src="//assets/js/jquery.nice-select.min.js"></script>
<!-- swiper js -->
<script src="//assets/js/slick.min.js"></script>
<script src="//assets/js/jquery.counterup.min.js"></script>
<script src="//assets/js/waypoints.min.js"></script>
<!-- custom js -->
<script src="//assets/js/custom.js"></script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</html>
